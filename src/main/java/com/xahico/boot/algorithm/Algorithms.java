
/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.xahico.boot.algorithm;

import java.util.Arrays;

/**
 * TBD.
 * 
 * @author Tuomas Kontiainen
**/
public final class Algorithms {
	/**
	 * Calculates the number of cycles to complete the linear iteration of 
	 * array {@code a}, where {@code a} is an array of 
	 * positive or neutral unique integers such as those generated by the 
	 * {@link Generators#generateEH0(int) EH0 generator algorithm}
	 * 
	 * @param a 
	 * Input array
	 * 
	 * @param breakAt 
	 * (optional) when to break or -1 if never
	 * 
	 * @return 
	 * Number of cycles or -1 if reached {@code breakAt}
	**/
	public static int clit (final int[] a, final int breakAt){
		int h;
		int n;
		int t;
		int x;
		
		t = 0;
		
		if (a.length > 0) {
			x = (a[0] - 1);
			h = (x + 1);
			t++;
			
			if (t == breakAt) {
				return -1;
			}
			
			for (var i = 1; i < a.length; i++) {
				n = a[i];
				
				if ((n == x) || ((n < x) && (n < (h - 1))) || (n > (h + 1))) {
					t++;
				}
				
				x = n;
				
				if (x > h) {
					h = x;
				}
			}
		}
		
		return t;
	}
	
	/**
	 * Generates {@code count} linearly unique numbers to array 
	 * {@code a} through detection of "missing numbers" 
	 * between those in {@code a} and padding from thereon.
	 * 
	 * @param a 
	 * Array of numbers to derive generation from
	 * 
	 * @param copy 
	 * If {@code true} creates a copy of {@code a}; 
	 * otherwise {@code a} will be sorted
	 * 
	 * @param count 
	 * Generation count (including padding)
	 * 
	 * @return 
	 * Generated array of numbers unique to {@code a}
	 */
	public static int[] cmiss (final int[] a, final boolean copy, final int count){
		final int[] ia;
		int         im;
		int         in;
		final int[] is;
		int         iu;
		
		// Optimize by checking if required linear iterations are not greater than one
		// If @clit returns other than -1 then the array is "already sorted" so 
		// there is no need to copy nor attempt to sort it.
		if ((a.length <= 1) && (clit(a, 2) != -1)) {
			is = a;
		} else {
			if (copy) {
				is = new int[a.length];

				System.arraycopy(a, 0, is, 0, a.length);
			} else {
				is = a;
			}
		
			Arrays.sort(is);
		}
		
		ia = new int[count];
		in = 0;
		im = 0;
		
		for (var i = 1; i < is.length; i++) {
			var j = i;
			var m = is[i - 1];
			var n = is[i];
			
			if (n > im) 
				im = n;
			
			do {
				n--;
				
				if (n <= m) 
					break;
				
				ia[in] = n;
				in++;
				j--;
			} while ((j > 0) && (in < ia.length) && (is[j - 1] != (n - 1)));
		}
		
		iu = (ia.length - in);
		
		for (var i = 0; i < iu; i++) {
			im++;
			ia[in] = im;
			in++;
		}
		
		return ia;
	}
	
	
	
	private Algorithms (){
		throw new UnsupportedOperationException("Not supported.");
	}
}